/**
 * 内容清理器
 * 负责移除DOM元素中不需要的内容，如按钮、AI声明、推荐问题等
 */
class ContentCleaner {
    constructor() {
        // 清理规则映射，可以根据网站定制
        this.cleaningRules = new Map();
        
        // 清理场景标识
        this.cleaningForCopy = false;

        // 初始化默认清理规则
        this.initializeDefaultRules();
    }

    /**
     * 清理DOM元素中的不需要内容
     * @param {HTMLElement} element - 要清理的DOM元素
     * @param {string} hostname - 网站域名
     * @param {boolean} isCopyScenario - 是否是复制场景
     * @returns {Promise<void>}
     */
    async clean(element, hostname = window.location.hostname, isCopyScenario = false) {
        try {
            this.cleaningForCopy = isCopyScenario;
            console.debug(`[ContentCleaner] Starting cleanup for ${hostname}, copy scenario: ${isCopyScenario}`);

            // 1. 移除复制按钮
            this.removeButtons(element);

            // 2. 移除AI声明
            this.removeAIStatements(element);

            // 3. 移除推荐问题
            this.removeRecommendedQuestions(element, hostname);

            // 4. 移除导航和菜单元素
            this.removeNavigationElements(element);

            // 5. 应用网站特定的清理规则
            await this.applyCustomRules(element, hostname);

            // 6. 清理空元素
            this.removeEmptyElements(element);

            console.debug(`[ContentCleaner] Cleanup completed for ${hostname}`);

        } catch (error) {
            console.error(`[ContentCleaner] Cleanup failed for ${hostname}:`, error);
            // 不抛出错误，避免阻塞格式化流程
        }
    }

    /**
     * 移除按钮元素
     * @param {HTMLElement} element - DOM元素
     */
    removeButtons(element) {
        console.debug('[ContentCleaner] Removing buttons');

        // 移除复制按钮容器
        element.querySelectorAll('.puretext-copy-btn, .puretext-button-container').forEach(btn => {
            console.debug('[ContentCleaner] Removing PureText button:', btn.textContent?.trim());
            btn.remove();
        });

        // 移除常见的操作按钮
        const buttonSelectors = [
            'button',
            '[role="button"]',
            '.btn',
            '.button',
            '[onclick]',
            'a[href="#"]',
            '.action',
            '.menu'
        ];

        buttonSelectors.forEach(selector => {
            element.querySelectorAll(selector).forEach(button => {
                const text = button.textContent?.trim();

                // 只移除特定的操作按钮，避免误删重要内容
                if (text && this.isOperationButton(text)) {
                    console.debug('[ContentCleaner] Removing operation button:', text);
                    button.remove();
                }
            });
        });
    }

    /**
     * 判断是否是操作按钮
     * @param {string} text - 按钮文本
     * @returns {boolean} 是否是操作按钮
     */
    isOperationButton(text) {
        const operationPatterns = [
            /^(复制|重试|分享|编辑|搜索|搜索一下|点赞|踩|收藏|删除|举报|更多)$/,
            /^(Copy|Retry|Share|Edit|Search|Like|Dislike|Save|Delete|Report|More)$/i,
            /^(コピー|再試行|共有|編集|検索|いいね|保存|削除|報告)$/,
            // 图标按钮（只包含符号）
            /^[👍👎❤️💾🔗📋🔄✏️🗑️⚙️]$/,
            // 空白或只有空格的按钮
            /^\s*$/
        ];

        return operationPatterns.some(pattern => pattern.test(text));
    }

    /**
     * 移除AI生成声明
     * @param {HTMLElement} element - DOM元素
     */
    removeAIStatements(element) {
        console.debug('[ContentCleaner] Removing AI statements');

        const aiStatementPatterns = [
            /本回答由\s*AI\s*生成.*内容仅供参考/,
            /This response was generated by AI.*for reference only/i,
            /AI\s*生成的回答/,
            /Generated by AI/i,
            /人工智能生成/,
            /机器生成内容/,
            /AI助手回复/,
            /智能助手生成/
        ];

        // 查找包含AI声明的元素
        const allElements = Array.from(element.querySelectorAll('*'));

        allElements.forEach(el => {
            const text = el.textContent?.trim();
            if (text && aiStatementPatterns.some(pattern => pattern.test(text))) {
                console.debug('[ContentCleaner] Removing AI statement:', text.substring(0, 50) + '...');
                el.remove();
            }
        });
    }

    /**
     * 移除推荐问题
     * @param {HTMLElement} element - DOM元素
     * @param {string} hostname - 网站域名
     */
    removeRecommendedQuestions(element, hostname) {
        console.debug('[ContentCleaner] Removing recommended questions');

        // 1. 通过CSS选择器移除明显的推荐问题区域
        const questionSelectors = [
            '[class*="recommend"]',
            '[class*="suggest"]',
            '[class*="related"]',
            '[class*="question"]',
            '[data-testid*="question"]',
            '[data-testid*="suggest"]',
            '.follow-up',
            '.next-question'
        ];

        questionSelectors.forEach(selector => {
            element.querySelectorAll(selector).forEach(el => {
                console.debug('[ContentCleaner] Removing question container by selector:', selector);
                el.remove();
            });
        });

        // 2. 基于文本模式的智能清理
        this.removeQuestionsByPattern(element);

        // 3. 应用网站特定的推荐问题清理规则
        this.applyHostnameSpecificQuestionCleaning(element, hostname);
    }

    /**
     * 基于文本模式移除推荐问题
     * @param {HTMLElement} element - DOM元素
     */
    removeQuestionsByPattern(element) {
        const allElements = Array.from(element.querySelectorAll('*'));

        allElements.forEach(el => {
            const text = el.textContent?.trim();
            if (text && this.isRecommendedQuestion(text)) {
                // 检查是否是独立的问题元素（不包含其他重要内容）
                if (this.isStandaloneQuestion(el)) {
                    console.debug('[ContentCleaner] Removing recommended question:', text.substring(0, 30) + '...');
                    el.remove();
                }
            }
        });
    }

    /**
     * 判断文本是否是推荐问题
     * @param {string} text - 文本内容
     * @returns {boolean} 是否是推荐问题
     */
    isRecommendedQuestion(text) {
        if (!text || text.length > 150) return false;

        const questionPatterns = [
            // 中文问题模式
            /^[^。！]*[？?]$/,  // 以问号结尾的短句
            /^(?:如何|怎么|什么是|什么叫|为什么|哪些|多少|何时|在哪|是否|能否|可以)[^。！]*[？?]$/,
            /^(?:谁|哪|什么|怎样|多少|几|何)[^。！]*[？?]$/,
            /[^。！]*(?:多久|什么时候|何时|时间|期限|周期)[^。！]*[？?]$/,
            /[^。！]*(?:多少|比例|费用|成本|价格|金额|数量)[^。！]*[？?]$/,
            /[^。！]*(?:如果|假如|要是|情况下|条件)[^。！]*[？?]$/,

            // 英文问题模式
            /^(How|What|Why|When|Where|Who|Which|Can|Could|Would|Should|Is|Are|Do|Does|Did)[^.!]*\?$/i,
            /^[^.!]*\?$/,  // 以问号结尾的英文句子

            // 特定领域问题（金融、技术等）
            /(?:保证金|强平|期货|交易|风险|合约|平仓|开仓)[^。！]*[？?]$/,
            /(?:API|接口|代码|函数|方法|算法)[^。！]*[？?]$/
        ];

        return questionPatterns.some(pattern => pattern.test(text));
    }

    /**
     * 判断元素是否是独立的问题元素
     * @param {HTMLElement} element - DOM元素
     * @returns {boolean} 是否是独立问题
     */
    isStandaloneQuestion(element) {
        // 检查元素是否只包含问题文本，没有其他重要内容
        const text = element.textContent?.trim();
        const children = element.children || [];

        // 如果元素有很多子元素，可能包含重要内容
        if (children.length > 3) {
            return false;
        }

        // 如果文本很长，可能不是简单的推荐问题
        if (text && text.length > 100) {
            return false;
        }

        // 检查是否包含非问题内容
        const hasNonQuestionContent = Array.from(children).some(child => {
            const childText = child.textContent?.trim();
            return childText && !this.isRecommendedQuestion(childText);
        });

        return !hasNonQuestionContent;
    }

    /**
     * 应用网站特定的推荐问题清理规则
     * @param {HTMLElement} element - DOM元素
     * @param {string} hostname - 网站域名
     */
    applyHostnameSpecificQuestionCleaning(element, hostname) {
        switch (hostname) {
            case 'www.kimi.com':
                this.cleanKimiRecommendedQuestions(element);
                break;
            case 'chat.deepseek.com':
                this.cleanDeepSeekRecommendedQuestions(element);
                break;
            default:
                // 通用清理已经在上面完成
                break;
        }
    }

    /**
     * 清理Kimi网站的推荐问题
     * @param {HTMLElement} element - DOM元素
     */
    cleanKimiRecommendedQuestions(element) {
        // Kimi特有的推荐问题容器
        const kimiQuestionSelectors = [
            '.recommend-prompt-list',
            '.recommend-prompt',
            '.recommend-prompt-item',
            '[class*="recommend"]'
        ];

        kimiQuestionSelectors.forEach(selector => {
            element.querySelectorAll(selector).forEach(el => {
                console.debug('[ContentCleaner] Removing Kimi question container:', selector);
                el.remove();
            });
        });
    }

    /**
     * 清理DeepSeek网站的推荐问题
     * @param {HTMLElement} element - DOM元素
     */
    cleanDeepSeekRecommendedQuestions(element) {
        // DeepSeek特有的推荐问题模式
        // 通常DeepSeek的推荐问题较少，主要依赖通用清理
    }


    /**
     * 移除导航和菜单元素
     * @param {HTMLElement} element - DOM元素
     */
    removeNavigationElements(element) {
        console.debug('[ContentCleaner] Removing navigation elements');

        const navigationSelectors = [
            'nav',
            '.navigation',
            '.nav',
            '.menu',
            '.sidebar',
            '.header',
            '.footer',
            '.breadcrumb',
            '.pagination',
            '[role="navigation"]',
            '[role="menu"]',
            '[role="menubar"]'
        ];

        navigationSelectors.forEach(selector => {
            element.querySelectorAll(selector).forEach(el => {
                // 只移除明显的导航元素，避免误删内容
                if (this.isNavigationElement(el)) {
                    console.debug('[ContentCleaner] Removing navigation element:', selector);
                    el.remove();
                }
            });
        });
    }

    /**
     * 判断是否是导航元素
     * @param {HTMLElement} element - DOM元素
     * @returns {boolean} 是否是导航元素
     */
    isNavigationElement(element) {
        const text = element.textContent?.trim();

        // 如果包含大量文本内容，可能不是纯导航元素
        if (text && text.length > 200) {
            return false;
        }

        // 检查是否包含导航相关的关键词
        const navigationKeywords = [
            '首页', '主页', '返回', '上一页', '下一页', '菜单', '导航',
            'Home', 'Back', 'Next', 'Previous', 'Menu', 'Navigation',
            'ホーム', 'メニュー', 'ナビゲーション'
        ];

        return navigationKeywords.some(keyword => text?.includes(keyword));
    }

    /**
     * 应用网站特定的清理规则
     * @param {HTMLElement} element - DOM元素
     * @param {string} hostname - 网站域名
     * @returns {Promise<void>}
     */
    async applyCustomRules(element, hostname) {
        const rules = this.cleaningRules.get(hostname);

        if (rules && rules.length > 0) {
            console.debug(`[ContentCleaner] Applying ${rules.length} custom rules for ${hostname}`);

            for (const rule of rules) {
                try {
                    await rule(element);
                } catch (error) {
                    console.error(`[ContentCleaner] Custom rule failed for ${hostname}:`, error);
                }
            }
        }
    }

    /**
     * 清理空元素
     * @param {HTMLElement} element - DOM元素
     */
    removeEmptyElements(element) {
        console.debug('[ContentCleaner] Removing empty elements');

        // 多次清理，因为移除元素后可能产生新的空元素
        let removedCount = 0;
        let maxIterations = 5;

        for (let i = 0; i < maxIterations; i++) {
            const emptyElements = Array.from(element.querySelectorAll('*')).filter(el => {
                return this.isEmpty(el) && this.isSafeToRemove(el);
            });

            if (emptyElements.length === 0) {
                break;
            }

            emptyElements.forEach(el => {
                el.remove();
                removedCount++;
            });
        }

        if (removedCount > 0) {
            console.debug(`[ContentCleaner] Removed ${removedCount} empty elements`);
        }
    }

    /**
     * 判断元素是否为空
     * @param {HTMLElement} element - DOM元素
     * @returns {boolean} 是否为空
     */
    isEmpty(element) {
        const text = element.textContent?.trim();
        const children = element.children;

        // 有文本内容则不为空
        if (text && text.length > 0) {
            return false;
        }

        // 有子元素则不为空
        if (children.length > 0) {
            return false;
        }

        // 检查是否有重要的属性（如图片的src）
        if (element.tagName === 'IMG' && element.src) {
            return false;
        }

        return true;
    }

    /**
     * 判断元素是否可以安全移除
     * @param {HTMLElement} element - DOM元素
     * @returns {boolean} 是否可以安全移除
     */
    isSafeToRemove(element) {
        // 不移除重要的结构性元素
        const importantTags = ['html', 'head', 'body', 'main', 'article', 'section'];

        if (importantTags.includes(element.tagName.toLowerCase())) {
            return false;
        }

        // 不移除有重要属性的元素
        if (element.id || element.hasAttribute('data-important')) {
            return false;
        }

        return true;
    }

    /**
     * 注册网站特定的清理规则
     * @param {string} hostname - 网站域名
     * @param {Function} rule - 清理规则函数
     */
    registerCleaningRule(hostname, rule) {
        if (!this.cleaningRules.has(hostname)) {
            this.cleaningRules.set(hostname, []);
        }

        this.cleaningRules.get(hostname).push(rule);
        console.debug(`[ContentCleaner] Registered cleaning rule for ${hostname}`);
    }

    /**
     * 初始化默认清理规则
     */
    initializeDefaultRules() {
        // 为特定网站注册默认规则

        // Kimi网站特定规则
        this.registerCleaningRule('www.kimi.com', (element) => {
            // 移除Kimi特有的界面元素
            element.querySelectorAll('.segment-generate-tip').forEach(el => el.remove());
            
            // 只在复制场景下移除按钮容器，不在注入场景下移除
            if (this.cleaningForCopy) {
                element.querySelectorAll('.segment-assistant-actions').forEach(el => el.remove());
                console.debug('[ContentCleaner] Removed segment-assistant-actions in copy scenario');
            } else {
                console.debug('[ContentCleaner] Preserved segment-assistant-actions in injection scenario');
            }
        });

        // DeepSeek网站特定规则
        this.registerCleaningRule('chat.deepseek.com', (element) => {
            // DeepSeek通常有良好的HTML结构，主要做基本清理
            element.querySelectorAll('[class*="action"], [class*="toolbar"]').forEach(el => el.remove());
        });

    }

    /**
     * 清除所有清理规则
     * 主要用于测试
     */
    clearRules() {
        this.cleaningRules.clear();
        console.debug('[ContentCleaner] All cleaning rules cleared');
    }
}

// 导出类
export { ContentCleaner };